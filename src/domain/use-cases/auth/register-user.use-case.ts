import { Injectable, Inject, ConflictException } from '@nestjs/common';
import { INJECTION_TOKENS } from '../../../shared/constants/injection-tokens';
import { UserRepositoryInterface } from '../../repositories/user.repository.interface';
import { IPasswordService } from '../../../shared/interfaces/password.service.interface';
import { IJwtService } from '../../../shared/interfaces/jwt.service.interface';
import { User, UserRole } from '../../entities/user.entity';

interface RegisterUserRequest {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
}

export interface RegisterUserResponse {
  user: User;
  accessToken: string;
}

@Injectable()
export class RegisterUserUseCase {
  constructor(
    @Inject(INJECTION_TOKENS.USER_REPOSITORY)
    private readonly userRepository: UserRepositoryInterface,
    @Inject(INJECTION_TOKENS.PASSWORD_SERVICE)
    private readonly passwordService: IPasswordService,
    @Inject(INJECTION_TOKENS.JWT_SERVICE)
    private readonly jwtService: IJwtService,
  ) {}

  async execute(request: RegisterUserRequest): Promise<RegisterUserResponse> {
    // Check if user already exists
    const existingUser = await this.userRepository.findByEmail(request.email);
    if (existingUser) {
      throw new ConflictException('User with this email already exists');
    }

    // Hash the password
    const hashedPassword = await this.passwordService.hash(request.password);

    // Create the user
    const user = new User(
      '', // ID will be generated by repository
      request.email,
      request.firstName,
      request.lastName,
      hashedPassword,
      UserRole.CUSTOMER, // Default role
    );

    const createdUser = await this.userRepository.create(user);

    // Generate JWT token
    const accessToken = await this.jwtService.generateToken({
      userId: createdUser.id,
      email: createdUser.email,
      role: createdUser.role,
    });

    return {
      user: createdUser,
      accessToken,
    };
  }
}